var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import buildOpts from './buildOpts';
import checkArg from './checkArg';
import { request } from './http';
const validOptions = [
    'fields',
    'filterByFormula',
    'maxRecords',
    'pageSize',
    'sort',
    'view',
    'where',
];
/**
 * The main AsyncAirtable class.
 */
export class AsyncAirtable {
    /**
     * Creates a new instance of the AsyncAirtable library.
     * @param apiKey The API Key from AirTable
     * @param base The base id from AirTable
     * @param config The config to use for this instance of AsyncAirtable
     */
    constructor(apiKey, base, config) {
        /**
         * Select record(s) from the specified table.
         * @param table Table name
         * @param options Options object, used to filter records
         * @param page Used to get a specific page of records
         * @returns
         * @async
         */
        this.select = (table, options, page) => __awaiter(this, void 0, void 0, function* () {
            try {
                checkArg(table, 'table', 'string');
                checkArg(options, 'options', 'object', false);
                checkArg(page, 'page', 'number', false);
                const url = `${this.baseURL}/${this.base}/${table}`;
                const opts = options ? Object.assign({}, options) : {};
                Object.keys(opts).forEach((option) => {
                    if (!validOptions.includes(option)) {
                        throw new Error(`Invalid option: ${option}`);
                    }
                });
                let offset = '';
                let data = [];
                if (page) {
                    for (let i = 0; i < page; i++) {
                        if (offset) {
                            opts.offset = offset;
                        }
                        try {
                            const body = yield request({
                                endpoint: `${url}?${buildOpts(opts)}`,
                                options: { headers: { Authorization: `Bearer ${this.apiKey}` } },
                                instance: this,
                                pageHandler: {
                                    index: i,
                                    page: page,
                                },
                            });
                            if (i + 1 === page) {
                                return body.records;
                            }
                            offset = body.offset;
                        }
                        catch (err) {
                            throw new Error(err);
                        }
                    }
                }
                else {
                    let done = false;
                    while (!done) {
                        if (offset) {
                            opts.offset = offset;
                        }
                        try {
                            const body = yield request({
                                endpoint: `${url}?${buildOpts(opts)}`,
                                options: {
                                    headers: { Authorization: `Bearer ${this.apiKey}` },
                                },
                                instance: this,
                            });
                            data = data.concat(body.records);
                            offset = body.offset;
                            if (!body.offset) {
                                done = true;
                            }
                        }
                        catch (err) {
                            throw new Error(err);
                        }
                    }
                }
                return data;
            }
            catch (err) {
                throw new Error(err);
            }
        });
        /**
         * Finds a record on the specified table.
         * @param table Table name
         * @param id Airtable record ID
         * @returns
         * @async
         */
        this.find = (table, id) => __awaiter(this, void 0, void 0, function* () {
            try {
                checkArg(table, 'table', 'string');
                checkArg(id, 'id', 'string');
                const url = `${this.baseURL}/${this.base}/${table}/${id}`;
                const data = yield request({
                    endpoint: url,
                    options: {
                        headers: { Authorization: `Bearer ${this.apiKey}` },
                    },
                    instance: this,
                });
                return data;
            }
            catch (err) {
                throw new Error(err);
            }
        });
        /**
         * Creates a new record on the specified table.
         * @param table - Table name
         * @param record - Record object, used to structure data for insert
         * @param typecast - Used for allowing the ability to add new selections for Select and Multiselect fields.
         * @returns
         * @async
         */
        this.createRecord = (table, record, typecast) => __awaiter(this, void 0, void 0, function* () {
            try {
                checkArg(table, 'table', 'string');
                checkArg(record, 'record', 'object');
                checkArg(typecast, 'typecast', 'boolean', false);
                const url = `${this.baseURL}/${this.base}/${table}`;
                const body = { fields: record };
                if (typecast !== undefined) {
                    body.typecast = typecast;
                }
                const data = yield request({
                    endpoint: url,
                    instance: this,
                    options: {
                        method: 'post',
                        body: JSON.stringify(body),
                        headers: {
                            Authorization: `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                        },
                    },
                });
                return data;
            }
            catch (err) {
                throw new Error(err);
            }
        });
        /**
         * Updates a record on the specified table.
         * @param table - Table name
         * @param record - Record object, used to update data within a specific record
         * @param opts - An object with options for your update statement
         * @returns
         * @async
         */
        this.updateRecord = (table, record, opts) => __awaiter(this, void 0, void 0, function* () {
            try {
                checkArg(table, 'table', 'string');
                checkArg(record, 'record', 'object');
                if (opts) {
                    checkArg(opts.destructive, 'opts.desctructive', 'boolean');
                    checkArg(opts.typecast, 'opts.typecast', 'boolean', false);
                }
                const url = `${this.baseURL}/${this.base}/${table}/${record.id}`;
                const body = { fields: record.fields };
                if ((opts === null || opts === void 0 ? void 0 : opts.typecast) !== undefined) {
                    body.typecast = opts === null || opts === void 0 ? void 0 : opts.typecast;
                }
                const data = yield request({
                    endpoint: url,
                    instance: this,
                    options: {
                        method: (opts === null || opts === void 0 ? void 0 : opts.destructive) ? 'put' : 'patch',
                        body: JSON.stringify(body),
                        headers: {
                            Authorization: `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                        },
                    },
                });
                return data;
            }
            catch (err) {
                throw new Error(err);
            }
        });
        /**
         * Deletes a record from the specified table.
         * @param table - Table name
         * @param id - Airtable record ID
         * @returns
         * @async
         */
        this.deleteRecord = (table, id) => __awaiter(this, void 0, void 0, function* () {
            try {
                checkArg(table, 'table', 'string');
                checkArg(id, 'id', 'string');
                const url = `${this.baseURL}/${this.base}/${table}/${id}`;
                const data = yield request({
                    endpoint: url,
                    instance: this,
                    options: {
                        method: 'delete',
                        headers: {
                            Authorization: `Bearer ${this.apiKey}`,
                        },
                    },
                });
                return data;
            }
            catch (err) {
                throw new Error(err);
            }
        });
        /**
         * Creates multiple new records on the specified table.
         * @param table - Table name
         * @param records - An array of Record objects
         * @param typecast - Used for allowing the ability to add new selections for Select and Multiselect fields.
         * @returns
         * @async
         */
        this.bulkCreate = (table, records, typecast) => __awaiter(this, void 0, void 0, function* () {
            try {
                checkArg(table, 'table', 'string');
                checkArg(records, 'records', 'array');
                checkArg(typecast, 'typecast', 'boolean', false);
                const url = `${this.baseURL}/${this.base}/${table}`;
                const body = {
                    records: records.map((record) => ({
                        fields: record,
                    })),
                };
                if (typecast !== undefined) {
                    body.typecast = typecast;
                }
                const data = yield request({
                    endpoint: url,
                    options: {
                        method: 'post',
                        body: JSON.stringify(body),
                        headers: {
                            Authorization: `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                        },
                    },
                    instance: this,
                });
                return data.records;
            }
            catch (err) {
                throw new Error(err);
            }
        });
        /**
         * Updates multiple records on the specified table
         * @param table - Table name
         * @param records - An array of Record objects
         * @param opts - An object with options for your update statement
         * @returns
         * @async
         */
        this.bulkUpdate = (table, records, opts) => __awaiter(this, void 0, void 0, function* () {
            try {
                checkArg(table, 'table', 'string');
                checkArg(records, 'records', 'array');
                if (opts) {
                    checkArg(opts.destructive, 'opts.desctructive', 'boolean', false);
                    checkArg(opts.typecast, 'opts.typecast', 'boolean', false);
                }
                const url = `${this.baseURL}/${this.base}/${table}`;
                const body = { records };
                if ((opts === null || opts === void 0 ? void 0 : opts.typecast) !== undefined) {
                    body.typecast = opts === null || opts === void 0 ? void 0 : opts.typecast;
                }
                const data = yield request({
                    endpoint: url,
                    options: {
                        method: (opts === null || opts === void 0 ? void 0 : opts.destructive) ? 'put' : 'patch',
                        body: JSON.stringify(body),
                        headers: {
                            Authorization: `Bearer ${this.apiKey}`,
                            'Content-Type': 'application/json',
                        },
                    },
                    instance: this,
                });
                return data.records;
            }
            catch (err) {
                throw new Error(err);
            }
        });
        /**
         * Deletes multiple records from the specified table
         * @param table - Table name
         * @param ids - Array of Airtable record IDs
         * @returns
         * @async
         */
        this.bulkDelete = (table, ids) => __awaiter(this, void 0, void 0, function* () {
            try {
                checkArg(table, 'table', 'string');
                checkArg(ids, 'ids', 'array');
                let query = '';
                ids.forEach((id, i) => {
                    if (i !== 0) {
                        query = `${query}&records[]=${id}`;
                    }
                    else {
                        query = `records[]=${id}`;
                    }
                });
                const url = `${this.baseURL}/${this.base}/${table}?${encodeURI(query)}`;
                const data = yield request({
                    endpoint: url,
                    options: {
                        method: 'delete',
                        headers: {
                            Authorization: `Bearer ${this.apiKey}`,
                        },
                    },
                    instance: this,
                });
                return data.records;
            }
            catch (err) {
                throw new Error(err);
            }
        });
        /**
         * Checks if a record exists, and if it does updates it, if not creates a new record.
         * @param table - Table name
         * @param filterString - The filter formula string used to check for a record
         * @param record - Record object used to either update or create a record
         * @param opts - An object with options for your update statement
         * @returns
         * @async
         */
        this.upsertRecord = (table, filterString, record, opts) => __awaiter(this, void 0, void 0, function* () {
            checkArg(table, 'table', 'string');
            checkArg(filterString, 'filterString', 'string');
            checkArg(record, 'record', 'object');
            if (opts) {
                checkArg(opts.destructive, 'opts.desctructive', 'boolean', false);
                checkArg(opts.typecast, 'opts.typecast', 'boolean', false);
            }
            const exists = yield this.select(table, { filterByFormula: filterString });
            if (!exists[0]) {
                return yield this.createRecord(table, record, opts === null || opts === void 0 ? void 0 : opts.typecast);
            }
            else {
                return yield this.updateRecord(table, {
                    id: exists[0].id,
                    fields: record,
                }, opts);
            }
        });
        if (!apiKey)
            throw new Error('API Key is required.');
        if (!base)
            throw new Error('Base ID is required.');
        this.apiKey = apiKey;
        this.base = base;
        this.retryOnRateLimit = (config === null || config === void 0 ? void 0 : config.retryOnRateLimit) || true;
        this.retryTimeout = (config === null || config === void 0 ? void 0 : config.retryTimeout) || 5000;
        this.maxRetry = (config === null || config === void 0 ? void 0 : config.maxRetry) || 60000;
        this.baseURL = (config === null || config === void 0 ? void 0 : config.baseURL) || 'https://api.airtable.com/v0';
    }
}
if (typeof window !== 'undefined') {
    window.AsyncAirtable = AsyncAirtable;
}
export const CREATED_TIME = () => 'CREATED_TIME()';
export const NOW = () => 'NOW()';
export const TODAY = () => 'TODAY()';
export const ERROR = () => 'ERROR()';
export const LAST_MODIFIED_TIME = () => 'LAST_MODIFIED_TIME()';
export const RECORD_ID = () => 'RECORD_ID()';
//# sourceMappingURL=asyncAirtable.js.map